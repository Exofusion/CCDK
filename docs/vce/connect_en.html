<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<link rel="stylesheet" href="../vce.css" type="text/css">
<title>VCE #VER# official document (English) </title>
<!-- English edited 4/7/15 CW -->
</head>


<BODY>
<H1>Connecting from VCE clients 
</H1>
<P>
The following describes success/failure conditions for VCE clients connecting to a VCE server.
</P>
<H2>Recommended Connection Methods</H2>
<P>It is recommended that connection tests are performed using only the vce_conn_writable function, and connection of non-blocking encryption in VCE applications.
</P>
<PRE>tcpcontext_t t = vce_tcpontext_create( 0, ... );
conn_t new_con = vce_tcpcontext_connect( t, "localhost" , 80 ); /* A */
while (1 ){
  vce_heartbeat();
  if( vce_conn_writable( new_con ) &gt;= 4 ){
    vce_conn_write( new_con, "test" , 4 ); /* write process */
  } else {
    /*  Error will occur if fixed time passes from A. */
  }
}      
</PRE>
<P>
In this case, when vce_conn_writable does not return a positive value within a fixed time using a timer, 
add the process to display an error on the client terminal to notify the user. 
Note that the above method is also effective even when not using encryption.</P>
<P>
By using VCE's "blocking connection," some pesky procedures 
such as test programs and server-monitoring programs can be omitted.
When you use the "blocking connection," 
you can check the connection success 
without looping, as below.
<br>
However, omitting procedures such as test programs and 
server-monitoring programs is often a requirement  to make it easily.
"Blocking connection" of VCE can be used for such a purpose.
</P>
<PRE>tcpcontext_t t = vce_tcpontext_create( 0, ... );
conn_t new_con = vce_tcpcontext_connect( t, "localhost" , 80 );
if( vce_conn_is_valid( new_con ) == 0 ){
  /* Error! Handy for determining problem. */
}
while (1 ){
  vce_heartbeat();
  if( vce_conn_writable(new_con)&gt;0 ){
    /* write process */
  }
}
</PRE>
<P>
However, when used in this fashion, it does not work as expected, 
and only when the server has reached the number of the absolute maximum number of connections.
Once it starts looping, vce_conn_writable returns an error.
Thus, the vce_conn_is_valid function returns success in the above example, since the server reached the maximum number of connections. (It's expected for vce_conn_writable to finally return an error, but the is that the first vce_conn_is_valid returns success.) 
</P>
<P>
This reason for this is the operation when reaching the maximum number of connections on the VCE server, since the connection is accepted once and then closed when the number of client connections reaches the preset maximum number.
VCE and other UNIX tools (Apache, etc.) behave in this fashion because of the following limitations on socket library functions:
</P>
<UL>
  <LI>The socket libraries of UNIX do not have any way to return "connection 
  refused", since the TCP/IP function does not have the concept of "maximum 
  connections" when some servers reach the maximum number of connections.
  <LI>Do not repeat binding/listening or releasing the same port near 
      the maximum number of the connections. 
      Although the operation mentioned above can be executed by repeating binding, 
      listening, or releasing again and again whenever it reaches the maximum number of connections, it will cause performance issues -- and a be a security hole -- so this is not recommended.
 </LI></UL>
<P>
Therefore, for server applications which currently run on UNIX, the operations will be accepted and then close the connection by default. 
</P>
<H2>How to use the maximum number of connections.</H2>
<P>
The operation explained above is the default for connecting above the maximum number of VCE connections. 
However, users who access a full server will not know whether the server is full or is down. 
</P>
<P>
So, VCE sets up a "temporary" number of maximum connections besides the absolute number of maximum connections, and it has the function to call other connection-monitoring functions when connections beyond the temporary number of maximum connections are accepted.
The other functions are vce_tcpcontext_set_circ_hiwater_acceptwatcher and vce_tcpcontext_set_conn_hiwater_acceptwatcher.  For details, refer to 
the vce_tcpcontext_set_conn_hiwater_acceptwatcher function. 
</P>

<p><br>

  <br>
  <a href="index.html">return to index</a></p>
<div id="footer">#COPYRIGHT#</div>

 
</BODY></HTML>
